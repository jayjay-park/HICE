,controversiality,parent_id,body,subreddit,id,score,subreddit_id
6340478,0,t3_42g5rf,,Forth,czacbim,2,t5_2qjkc
8250034,0,t3_4savbz,In my experience after telling people about Forth they get excited to learn it and then express fear of becoming addicted and not wanting tobeing able spend as much time with the programming languages that are going to make them money.,Forth,d58t6px,3,t5_2qjkc
8586478,0,t3_4xc039,Let me take a stab as an exercise Im not a Forth veteran. A struct implies manyyou dont reach for a struct when you have one of a thing you just make a few variables. You probably need at least three things to motivate a struct unless your things have a whole bunch of parts. Many structs will either be elements of an array or be instantiated in an adhoc way perhaps as black boxes that you use to communicate with a library or perhaps as an abstract data type like a vector. If its an element of an array what youve actually got is a table and a table is a kind of database. Take a step back and format your database and its accessors as a whole. If its for communication with a library you may be stuck with it. If its for communication between parts of your program see if you can simplify it by turning the part which would be managing the struct into a stateful portion of the program instead of having it be driven by struct data. This may imply a database if you actually need multiple sets of this state e.g. a database of sound files. If its an abstract data type rather than passing struct addresses on the stack maybe you want a couple of registers or a custom stack to hold this data type.,Forth,d6ewbrr,5,t5_2qjkc
9028696,0,t3_53wq5p,Great answer!  I learned more about gdb in five minutes than in the previous five years.,Forth,d7x3v8l,3,t5_2qjkc
9296378,0,t1_d8u5c5z,EDIT I replied to the wrong person . utransfire this is meant for you too. Sorry for the confusion thamesynnegt So heres my modest proposal as an addendum to the above suggestion. By all means add A B X and Y  but have them cleared by  so theres no danger people will start to use them to pass or hold parametersForth has always made use of variables where appropriate and registers are really just fast variables in the processor. In this light I dont see any reason to force clear registers and this would destroy the utility of the address registers in order to be able to clear the registers when a function returns you would need another stack which manages them otherwise your registers would be cleared whenever you called another word.As you pointed out once we start adding stacks for specific tasks then the complexity of the model explodes.Two address registers with possible base registers seems to be a sweet spot. They enables a lot of really simple very efficient solutions for the minimum cost. Its true that these registers can be used for temporary storage but since you need to access memory so frequently you cant keep things there very long. Why force clear them? Theres no need Unless youre going to remove variables then you cant really stop people from doing this kind of thing. Unless youre going to go out of your way to back these things by real registers theyre not going to be faster so we really are talking about variable here.In general Id recommend against trying to protect people from themselves. Doing can only ever adds complexity and unless you plan to lock down your system to the point that its no different from any other managed language youre not going to succeed anyway .gt Instead I am thinking each word when executed will get a private scratch stack it can manipulate without worrying about clearing it. It will be thrown away anyway when the words ends. I dont think that you necessarily need to make this a central part of the system.  Its easy to implement this if you need it and you probably arent gonna need it. Ive been working with Forth for the past few years and Ive never needed this.  If you follow the common advice about keeping your stack small then not only will you have to do less stack juggling but cleaning up wont be such a problem.I recommend keeping your stack shallow because it forces you to simplify.I dont use local variables or pick at all because it allows code to become much more complex than it would be otherwise and makes factoring more difficult. I do however use variables quite liberally. Otherwise Ive become quite comfortable with manipulating the stack and understanding code which manipulates it.The trick is learning to read the intention by considering more than one word. Id like to finish this by taking a small detour to look at some common phrases. For example The phrase     swap  swapMeans to increment the top two values.    swap is the same but it implies that the order of the top two values doesnt matter and is more efficient.More generally   f swap f swapWhere f is a word with shape u  u means to apply f to the top two values.The phrase    swap f swapWhere f is a word with shape u  u means to apply f to the second value.The phrase    pull this pushis the value at the top of the call stack. Some Forths use the name c here.I sometimes read swap as under when its use is to slide the first value under the second value. Given that the phraseThe phrase    swap dropMeans to drop the second value. This is  usually called nip but that name is really rather arbitrary so I prefer to write swap drop. When I see these two words together I read it as under drop.    swap push swap pullMeans to slide the first value under the second and third values on the stack. This is often called rot but understood like this pattern is easy to recognize and used generally can be used to sink a value to almost any depth on the stack.The phrase    swap push swap push swap pull pullsinks the first value under the second third and fourth values on the stack.This is about as complex as it should get. If you need access to more items on the stack than this then you should consider using one or more variables.A final advantage to learning to code read like this is that it makes the cost involved in each operation transparent. If your stack really is a stack then you absolutely do not want to use pick etc. theres a lot of stack juggling going on and you should really be aware of that. If your stack is an array then you need to ask yourself why youre using Forth it seems like what you want is a more traditional stackframe approach . In that case my preference would be to  use variables to eschew excessive juggling  build a data structure in memory and pass its address around instead or if theres only one such structure then resolve the address compile time instead and dont pass it on the stack at all.DISCLAIMER I may be a bit of a purist when it comes to Forth but hopefully this discussion has been somewhat useful ,Forth,d8uds49,2,t5_2qjkc
9313411,0,t1_d8w4cv6,ltgt execute,Forth,d8wjkj1,3,t5_2qjkc
10883427,0,t3_5vhr0e,    define BEGIN     define END ,Forth,de2jqqi,1,t5_2qjkc
11761661,0,t1_dgt6bmh,Then surely the easiest way is to build a SEE that can be redirected into another devices input?ed. Also  huh? You want to use a dumb terminal without even the ability to log whats typed into it to enter code on the fly into a system based on an  bit microcontroller which cant execute code from RAM in an application where cost is frankly the least of your concerns? When it would be infinitely more convenient to use a more powerful controller or SBC in the device itself andor use an umbilical arrangement that both leaves more of your device free to do interesting things and uses more of your hosts power than just running a terminal app?Unless you have an unshakeable aesthetic desire to hook a VT up to your Eurorack system please consider that you can do a bit better than the very worst of all possible implementation strategies.,Forth,dgt7pfk,1,t5_2qjkc
