,controversiality,parent_id,body,subreddit,id,score,subreddit_id
5923788,0,t1_cxvrebn,Not every one uses an advanced editor or IDE to do their work. Personally I use Leafpad which is pretty minimal.I use the shorthand versions of registers because thats how the official documentation names them as far as ARM is concerned in this example and it reduces visual clutter.,EmuDev,cxw51n5,1,t5_37zrk
6408572,0,t1_czhxt2j,Tried JIT at one point. The thing is though is that I designed the emulator for accuracy even though it has timing bugs causing it to be inaccurate for the time being. JIT techniques have the particular issue of bailing out if you need to IRQ at precise times in the middle of a block. Also in JS there is waaaaaaaay too much jank with JIT compilation. Hell even the interpreter janks the fuck out for a second when warming up for the first second of runtime.,EmuDev,czi38op,2,t5_37zrk
7326963,0,t1_d2azx9u,The thing that i am worried about is my memory management skills or rather my memory address skills. I dont know the first thing about memory addresses. ,EmuDev,d2b0xnn,2,t5_37zrk
8340318,0,t3_4tqcgq,Normally most of these test roms will print out the exact opcode that failed if the test fails. Example after intentionally breaking opcode x on my CPU Register B  Register C. This sort of behavior is usually a sign that some other instruction critical for executing the test properly is failing. You may want to take a particular look at all your branchingjumpsubroutine instructions. I know that after it prints out the Passed or Failed it should just be executing an infinite loop using them. But it could be a variety of things as well I dont know for sure. Its worth looking over everything.Edit To point some possibly relevant bits in the testers source assembly the routine called when a test passes is called testspassed in testing.s. After writing Passed youll notice it jumps to exit which is contained in runtime.s under exit.Edit  I spent a little time poking around the testers code in BGBs debugger. On the  test the program counter will point to CA after printing Passed to the console should be equivelant to line  on testing.s. ld a should indicate that the exit code is  meaning the test passed. Then itll jump to the exit routine. Upon that itll call a routine that pushes AF to the stack then calls two other subroutines pops AF back out then does a compare A with an imemdiate  to check what the exit code was. If it thinks the test was a fail it wont return on the ret c on the next instruction. If I manually change the C flag to be incorrect while ret c is being called it will produce an output similar to yours If I were you Id check to see if the A register is correct by the time that cp a executes and if so check if your CP instruction is executing correctly or if not check why the A register is wrong by the time it gets there. As well as check your conditional ret instructions if CP does seem to produce the right output. Hope that helps.Edit  The Failed should be whatever decimal number was in reg A when the CP failed. The fact that it prints out that black and white L tile is pretty odd but could be an unrelated issue.,EmuDev,d5k3e0n,2,t5_37zrk
9169702,0,t1_d8e6652,Gotcha.  Thanks for the explanation.  Im at the point where my CPU and interrupts are mostly done so it sounds like I shouldnt worry about the Mooneye tests until Im ready to get into the specific esoteric parts of my emulator.  The blargg tests Ive been using indeed as a sanity check and Im definitely not ready to touch sound emulation gtlt.Im still a bit confused about the HALT issue.  As a quick follow up in the case where IME is disabled the CPU will resume when an interrupt is ready but it wont execute the interrupt?  Am I understanding that correctly?  Or do you mean that the CPU resumes immediately if the IME is disabled?Heres some psuedo code for how I currently understand it        int HALT         ifIME            cpuHalted  true           when an interrupt occurs it will turn off cpuHalted           return   cycle count         else            halted but immediately resumed and next instruction is evaluated twice           return              EDIT also forgot to add PC should be incremented in both cases.Thanks for your help clearing this up.,EmuDev,d8ebtk8,1,t5_37zrk
9400099,0,t1_d97hn2g,Hey hey SameBoy is pure C not C! No Ive completely documented the two PCM registers. The two registers are nameless FFC Bit  is RW effect unknown written  for DMG ROMs and  CGB ROMs and FFC Locked after boot No read nor write bit  effects DMG mode bit  probably has no effect other bits have undocumented effects. In SameBoy theyre called GBIODMGEMULATIONINDICATION and GBIODMGEMULATION respectively.Implementing boot ROM functionality in the host is a bit tricky as it requires GUI for palette selection which is platform dependent and actually controlling the timing differences from the code. Its also cheating and ASM is fun!,EmuDev,d97j173,1,t5_37zrk
10381617,0,t3_5ooc9z,Adding NSF support ended up being a really good idea. Listening to chiptunes albums on something you made is surprisingly satisfying especially since new NSFs are being composed and released all the time which gives an excuse to go out and find a lot of them to test with.Also if someone wants an emulatory project but doesnt want to commit right this second to messing with scanline timing and supporting a billion mappers and all the other little headaches of finishing the emulator proper an NSF player seems to fit that bill.  You get a neat useful app complete in and of itself and it can be a readymade stepping stone to finishing the process the next time you want a cool project to work on.,EmuDev,dcktjsq,5,t5_37zrk
10665559,0,t1_ddg1wh6,SDL the one you linked seems to segfault a lot. Also seems to be missing some SDL calls and the documentationsamples seem to be nonexistent. It seems to have trouble creating a simple window also. From my experience.OpenTK seemed like too much complication for something as simple as drawing pixels. Ill look into it though as it seems like a good thing to learn.,EmuDev,ddg2krg,1,t5_37zrk
10732459,0,t1_ddmuatl,Well theres  commands on SDL library that can make your frame on screen freezes and gives you the pixels on screen the command that locks is called LockSurface where you put on it the screen handler the surface where the screen is then you gonna create a pointer that will point to the first byte on the frameiechar  pointer  surfacegtpixels  where surface is the name of the screen handler after that you need to clean the screen handler with a simple memsetscreenWIDTHHEIGHT should do it and now you can begin filling the screen with pixels from the graphic memory using a fory   yltSCREENHEIGHT y and inside it a forx xltSCREENWIDTH x which will run for every bit on screen and inside it you gonna put your screen handler directly upscaling from the VRAM of CHIPie screenxySCREENWIDTH  gfxxy ? xFFFFFF  x where the ternary operator on the end verifys if the pixel is setso it will be white or is unsetit will be black then you close the for on x and y SDLUnlockSurface your screen handler and SDLFlip it to update it its MUCH more simple and logic that way ,EmuDev,ddmz161,1,t5_37zrk
11188870,0,t3_5zqqcz,Knowing the hardware will definitely make an NES emulator easier to implement although I think dynamic recompiling would be overkill since modern CPUs are more than fast enough to interpret the  in realtime. Writing a  dynarec could however be a learning experience and the knowledge will help you if you ever decide to do the same thing for modern processors where dynamic recompilers make more of a difference in emulation performance. Starting on a simpler CPU will make learning easier.I have written emulators for both the GameBoy and NES and while the GameBoy is simpler in some regards it also has its fair share of quirks. It is is also much less documented than the NES some documentation is also fragmented across several sources or just plain wrong.Since your NES emulator was in hardware and your goal is to learn about software emulation implementing one in software sounds like a good idea. You are already very familiar with it which will allow you to focus more on implementation strategies and emulator architecture  invaluable skills for future emulator development.I personally find that it is easiest for me to get motivation when I am working on something new. If you decide to go the GameBoy route I would rate its emulation difficulty as comparableslightly less than that of the NES albeit not for the same reasons.As for libraries a few tried and true SDL good allinone solution SFML similar functionality to SDL and provides a nice objectoriented interface OpenGL particularly if you decide to do a D console eventually,EmuDev,df08u4q,5,t5_37zrk
