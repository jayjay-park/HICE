,controversiality,parent_id,body,subreddit,id,score,subreddit_id
3381143,0,t1_cpdn8jg,If you do not have prior experience with some other graphics API like DX you should not hold off learning GL. Even though a lot of things differ many of the basic things will be very much the same. The things you learn about coordinate systems writing GLSL shaders doing linear algebra transforming vectors lighting pixels rendering strategies like deferredforwardsf techniques like spherical harmonics cubemaps shadowmaps IBL imposters things like texture compression texture sampling dependent an independent texture fetches derivatives normal mappingbumpmappingetc ... will all be basically  the same and have always been basically the same between DX and GL. The amount of time you will waste now learning GL or DX specifics that do not help you when switching to vulkan later will not be as big as the time you lose by waiting for vulkan now learning nothing. And remember that it has yet to be proven how much vulkan will actually end up delivering  applying a dose of conservative thinking and moderating ones expectations does not hurt. Also remember that performance differences depend on application. Your average application that switches from GL to vulkan will not experience a x speedup. I would expect  of applications to not experience any speedup at all. That is counting things like nongame applications indiegames D games ... as average applications. Vulkan Mantle and Metal are specifically designed to give very demanding applications an advantage by allowing them to do certain things that you couldnt do before e.g. composing commandbuffers in parallel but only AAA titles which have dedicated engineers working on their renderingbackends will actually really be able to take full advantage of this  and taking advantage of it will mean you have to do more work. Your average engine will likely not bother multithreading their scenegraph traversal to compose commandbuffers in parallel.Vulkan will also put more work on the programmerside in general than GL  syncing will have to be more explictly handled where with GL the driver mostly does it for you resource management will require more work managing update frequencies of your uniforms et cetera. So I would expect vulkan to be much harder to learn for a beginner than GL.So in short if youre expecting vulkanmetalmantlewhatever to give you a speedup for free youll be disappointed. You will have to pay for it by writing more code and spending more effort learning the API. If you already know GL beforehand especially GL  AZDO techniques which already incoorporate a lot of the mantlevulkan thinking it probably wont be so bad.,vulkan,cpdobsz,35,t5_36btb
4833763,0,t1_cu3rur1,WebGl makes sense because it is a high level frame work that could be mapped to program the browser environment. When you are doing anything in the browser you are doing it for a walled off garden. WebGL is an acceleration framework to interface with JavaScript to allow running performant shaders in an environment that needs all the error checking and security bounds that OpenGL has built in.Vulkan is designed for an environment that can directly manage things like memory and multiple processors as well as managing the GPU directly. You cant do those things in JavaScript whether in the browser of through Node.js. So Vulkan isnt a good fit. They have different environment.One of the worries with something like Vulkan originally was the ability to not crash the GPU driver. OpenGL has bunches of checks in place to prevent those things while Vulkan has layers that arent meant to be used in production environments.They also have different audiences as those that are looking toward ease of use and fast iteration tend to go with JavaScript and the web environment while those that need maximum performance ten to go with CC and other low level languages.Now there is no reason something that is more Web specific cant be built on top of Vulkan but the Vulkan model is multithreaded and until multithreaded JavaScript in the browser is solved that will probably be a low priority. It is a problem that the Web standards committee is trying to solve if for no other purpose than for the Web Assembly project that transpiles CC code to work in the browser.Now the Youre so smart comment is ironic coming from you considering you started this discussion with Ive heard a claim. Please keep the discussion cordial as I am trying to answer your questions not trying to prove you wrong. I dont care if you are wrong I do care that the discussion is informative to others reading the post.,vulkan,cu3u2b0,3,t5_36btb
4841719,0,t1_cu4rlns,It isnt as straight forward as installing Windows on a Mac. With Linux you have to install reFind which forces the mac to see the Linux partition. Then you have to figure out a way to get Linux Broadcom drivers onto the OS so you can download driver updates cause the default ones dont work. Every few months I get this urge to try out Linux to see how it is so I download LinuxMint. Use it for about a week become frustrated that I cant install new graphics drivers then I remove it from my mac.,vulkan,cu4u3s5,2,t5_36btb
4841877,0,t1_cu4tdsk,gt just buy an external USB. harddrive and boot from itI like this idea. Thanks.,vulkan,cu4utj9,1,t5_36btb
4845750,0,t3_3h7g25,I was really looking forward to Vulkan.  The part where a next gen graphics api still bound things was cringe worthy.  While there are many of you who enjoy this method it was just about the only disappointment for me.I would like to pass via a parameter or in a data structure any graphics buffer to a Vulkan kernel call and do the memory management in the kernel manually. If the buffer just happened to not be a vertex buffer  it just would not work correctly.  I would like to not be limited by specifically binding stuff.  This was a problem for me in OpenGL and I see binding as a subpar method of coding.This is a personal opinion and your view can and will differ.,vulkan,cu5ccx3,-5,t5_36btb
5416426,0,t1_cw3z85q,You had to be there to appreciate the hysteria. It wasnt limited to that thread.,vulkan,cw409lu,2,t5_36btb
5866317,0,t1_cxob096,Not much of this year left to wait. Maybe you will have an extra present to play with for your Christmas break.It would probably be excessive to launch on the th though. Even Vulkan is not quite the second coming. Nearly but not quite.,vulkan,cxolsos,3,t5_36btb
5947070,0,t1_cxz6ljl,You mostly cannot map anything to gcm and its spu specifics. Read up on how those work and why are not similar to any other hw. Youd almost be in worse position than if you try emulating PPC on x. This is also reason why PS doesnt support it anymore.Another question is how do you expect answer on your question when Vulkan was not released yet. Unless you own some crystal ball...,vulkan,cxz6w0n,2,t5_36btb
5984299,0,t1_cy3wxid,deleted,vulkan,cy42n5r,1,t5_36btb
6245447,0,t1_cyzgvmt,Embrace and extend... Vulkan has extensions you know. It is part of the API like it is with OpenGL. NVIDIA exposes functionality that it is already there it is the intended purpose of extensions  this is why they exist.If you want to use them or not it is your choice but dont blame NVIDIA for providing additional functionality especially when this is exactly why extensions exist in the first place.And personally i do not hope for a bugged and unstable user experience on one of the most used vendors for high performance graphics. I hope for a fast and stable experience from both AMD and NVIDIA so that Vulkan will actually have a chance of being taken more seriously in the AAA gaming industry than OpenGL the last decade.,vulkan,cyzjfld,3,t5_36btb
6295532,0,t3_41ueaz,insert obligatory Just give us the API already! comment,vulkan,cz58bcn,35,t5_36btb
6304333,0,t1_cz5v5ob, ms is almost a full frame for a  fps game and as such is extremely long to spend on picking. A  GBs PCIe bus would take roughly  ms to move an  MB buffer so this definitely still sounds too long.A cheaper alternative would be to read the cursor position on the GPU using e.g. a compute shader write that to a tiny separate buffer and move just that back to the CPU. ,vulkan,cz68d18,3,t5_36btb
6598407,0,t1_d01scx1,HLSL is reasonably well documented but HLSL Bytecode is not officially documented at all.,vulkan,d01tuw9,1,t5_36btb
6599145,0,t3_462lwi,Looks like this is whats being referred to ,vulkan,d01wlre,5,t5_36btb
6613563,0,t1_d03c121,Gallium preGallium or both?,vulkan,d03ecvk,1,t5_36btb
6639220,0,t1_d060zep,AMD shipped drivers supporting ... To get things to work you need to use an older SDKs examples or build your apps to target .. at the highest. This is done by setting the apiVersion field when creating the vulkan instance.,vulkan,d061wp3,2,t5_36btb
6662504,0,t1_d08fptm,Sounds familiar now you mention it. I must have known that and forgotten . Feature sets supposedly per platform  ,vulkan,d08gkof,1,t5_36btb
6713825,0,t3_47keb3,Intel is the only company with totally unrelated linux and windows drivers the codebases and the developer teams are fully separated so the linux driver means nothing. I assume they will have one ready by the time games actually need vulkan.,vulkan,d0drmk1,11,t5_36btb
6721713,0,t1_d0ekt3p,No problem just to be fully compatible you should check the supported usage flags before using them of course color attachment and transfer destination should be available but you never know. Heres the specs relevant pointgtimageUsage must be a subset of the supported usage flags present in the supportedUsageFlags member ofthe VkSurfaceCapabilitiesKHR structure returned byvkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface,vulkan,d0el03x,2,t5_36btb
6856463,0,t1_d0tgkrl,this was an observation not necessarily a criticism ,vulkan,d0thlkt,3,t5_36btb
7191637,0,t3_4dy1pg,Using dlopen to access the library? Is that really a good approach?,vulkan,d1vmnb4,3,t5_36btb
7365484,0,t1_d2fe3y8,Yes theyre already aware of it.,vulkan,d2fekxn,1,t5_36btb
7380792,0,t1_d2h1n3u,You should add that if you care about the actual Vulkan Driver code AMD has stated their intention to Open Source theirs. Nvidia has not.You probably wont care about that unless you really want to know exactly why that one feature you added to your engine always crashes.,vulkan,d2h592a,8,t5_36btb
7930521,0,t3_4nvzw1,It would be nice if there was a premade solution for memory allocation in the form of a library that manages the pools for you. Repeating that work for every application is pointless and could be used by everything but the rare few applications that have special memory requirements.,vulkan,d47grgb,7,t5_36btb
7945127,0,t3_4o2uej,Uninitialized members in your deviceCreateInfo and deviceQueueCreateInfo,vulkan,d493uk9,3,t5_36btb
8334542,0,t3_4tqf7g,Your card is listed as supported on Nvidias website,vulkan,d5jdfa0,6,t5_36btb
8487237,0,t1_d6282zd,Would be pretty neat if they make it macro configurable stbstyle. ,vulkan,d62g941,3,t5_36btb
8575472,0,t1_d6dhj2u,Well. My bad. ,vulkan,d6dim9n,2,t5_36btb
8768233,0,t1_d6oe3dc,Off the top of my head Im afraid I dont. The main architectural differences I imagine will be in pipeline state management. Sorry about that.,vulkan,d71oyfn,1,t5_36btb
8775207,0,t1_d72j10y,I genuinely dont know of anyone really doing graphics work on freebsd or any bsd os other than macOS. So he might very well be one of the few in that niche. ,vulkan,d72kgp7,1,t5_36btb
8829692,0,t1_d78uhhl,I think the other thing to say is you can always write your own template code for it git it and just reuse it as you wish expanding on it over time. Then you only have to write it once or twice and then just modify and adapt it in future.,vulkan,d797evs,8,t5_36btb
8872912,0,t1_d7ed905,Not  sure but the oom error may be a bug in a specific SDK version. ,vulkan,d7eedgs,2,t5_36btb
8969016,0,t1_d7pvnix,You dont have to use device local memory  the GPU can still read from heap types that dont have DEVICELOCAL set its just going to potentially run slower as the GPU has to pull the data over the PCIE bus.If youd be rewriting and reuploading the data every frame anyway youre probably better off using nondevicelocal memory.,vulkan,d7pxuhc,5,t5_36btb
9032124,0,t3_53mjxs,It is awesome! For wasting your time with C.,vulkan,d7xio50,1,t5_36btb
9085609,0,t1_d83xmg6,There are no validation errors.It seems that data is passed to the shader because it works if I copy the array to a local variable.I will try to run it on other video card. If it also doesnt work something is wrong with my code.,vulkan,d83xz0a,1,t5_36btb
10194439,0,t1_dbz7wpf,Excellent!,vulkan,dbzlgcb,1,t5_36btb
11112921,0,t1_deddsup,deleted,vulkan,dern25c,1,t5_36btb
11311815,0,t3_61f79b,If you update the uniform buffer with vkCmdUpdateBuffer then there is no need for fence the update will happen on the gpu in the same frame as rendering you only need pipeline barriers.N times more buffers are beneficial if they are both accessed by the host and gpu because the gpu can lag behind the host by one frame. I think fences are a bad idea for this because it causes the host to wait to the previous frame to finish. So I would create N times command buffers.,vulkan,dfe6de4,2,t5_36btb
11514106,0,t3_64cobv,I think that you can just use vkMapMemory amp vkUnmapMemory.  almostThe same way you upload a texture.And the channels of the image are known at creation time of the texture most likely  STBIrgbalpha. ,vulkan,dg14j4h,2,t5_36btb
11809626,0,t1_dgyazhw,Weird. The gpulib author removed the code from GitHub after I linked it.  There are a couple forks still available ,vulkan,dgynuhf,2,t5_36btb
