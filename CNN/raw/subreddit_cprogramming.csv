,controversiality,parent_id,body,subreddit,id,score,subreddit_id
823275,0,t3_23k7t2,    scanfi ampcount?Why use a pointer to int for count anyways? Is that part of the assignment?Also in inputTempInfo        int i count        double Cels        for i   i lt count i Can you explain what i lt count is going to produce when count has no value?,cprogramming,cgxuwqz,1,t5_2rzb3
3546886,0,t3_30x0ad,With colors!Ive had variations of this idea for a while but only finally implemented it. Its based on ideas I had while making a simpler version of this header years ago.I wanted something that was could be used for any type without having to specify type or format strings. Generic is a bit cleaner for that then the combo of builtintypescompatiblep amp builtinchooseexpr and should theoretically work on the newest microsoft c compiler but is still a bit sucky thanks to the requirment that each branch be a valid c expression.I also wanted a nice typesafe way to add options by name.Designated struct initializers let me do that and I think might work on the latest Microsoft c compilers. Im sort of curious if its possible to use macros to abstract over named initializers in c and something else in c.I wanted  runtime not macro configuration including disablingchaning color for groups of DEBUGPRINT statements.Unfortunatly I used typeof so it currently will absolutley not work onmicrosofts c compiler but I hope to port it in the future. Anyone know a way to do this without violating DRY with limited typeof using Generic?Look in example.c for some of the options.Currently should work in  gccgt. due to use of designated initializers and llvmclang gt.P.S. is there a way to discourage use of meant to be private typesmacrosfunctions apparently leading underscores are supposed to be reserved in c for the cunix libraries.,cprogramming,cpwkfy3,1,t5_2rzb3
6028292,0,t1_cy9eza6,Youre rude and acting like a child. You should reevaluate yourself. ,cprogramming,cy9tv6s,6,t5_2rzb3
6994920,0,t3_47n3yg,gt method  strtokmethod  gt  path  strtokpath  gt  version  strtokversion rnYou are passing in unitialized char  here to strtok ie.  path and version.Also in order to get the next part you want to pass NULL into strtok as the first parameter whatever delimiter you want for the next parsee.g.    path  strtokNULL      version  strtokNULL  See  for manual ,cprogramming,d197tql,1,t5_2rzb3
8447608,0,t3_4vcwzx,Generally speaking its because you cannot determine the size of a Cstyle array outside of the original declaration. If you pass such an array to another function there is no way of telling how large the array is a very useful piece of information since all you have access to is a pointer to the first element of the array.Example    void someFuncint arr    int main         int array        for int i   i lt  i             arrayi  i                    someFuncarray            void someFuncint arr          What is the size of arr? sizeofarr will return the size of a pointer and sizeofarr will return the size of an int        If you wanted to perform an operation across each element of the array you would need to know the size and a size parameter is therefore useful.,cprogramming,d5xhl3k,1,t5_2rzb3
8615534,0,t3_4xrwdk,As it was mentioned before you should use fgets since it is besides the choice of a file stream a safer function for you can limit the amount of characters which will be written on the file stream. In your case    fgetssentence  STDIN I would like to call out first. You should not use variables as float if you merely intend to postincrement i. Use an unsigned integer    unsigned int i      float avg  .fNext thing is that you increment the current pointer from sentence.At the end of your for loop the position of sentence points to the  terminating character . Hence strlen results in  because you give it the address of the .To avoid this you could either use an array declaration in your header such as    float computeaveragewordlengthconst char sentenceand change your for loop in terms of that    int count  additional loop count value needed      forcount   count lt  count        ifsentencecount               iThe other option you might be more interested in as it needs less change keep the header as it is except change the double to float since its cleaner as you return a  byte float value not an  one and use a buffer value to safe the starting point of your character string    ...    const char buf  sentence  save the starting point of sentence     unsigned int i      float avg  .f        whilesentence !         ifsentence               i    avg  float strlenbuf  i   i     float cast so the dividing results as float values not as integer     return avg    ...Keep in mind that I only decked the syntax part. Whether the calculations are correct is still your job. Hope it helps! couldnt check at the moment if it works correctly     ,cprogramming,d6ijg1l,2,t5_2rzb3
9515677,0,t1_d9lzxrd,Well if the array is only holding pointers then all pointers should be a fixed size and the division would work out. On  bit the pointers may be bigger but but when you divide by sizeofpointer it will even out. Pointers have to be a fixed size because it deals with memory addresses which are also fixed. ,cprogramming,d9m0dcs,1,t5_2rzb3
11488263,0,t3_63t6sm,Use valgrind and gdb. Array overflows are simple to avoid simply by using  malloc.,cprogramming,dfy6yyp,2,t5_2rzb3
