,controversiality,parent_id,body,subreddit,id,score,subreddit_id
657579,0,t1_cgeywwm,That is accurate to some extent. But for that to be known it has to be evaluated. If you had that at the top level it would probably be CAFed and if you were to use it again it would most likely not be evaluated again. That is if you try something like    foo   ..  !!     main  do         print foo  Takes time because foo is forced        print foo  foo has been evaluated. Instant.,haskellquestions,cgf0lml,1,t5_2trze
1326637,0,t3_29888a,The .o files contain the compiled object code for their corresponding modules i.e. the machine code that the compiler generated which the linker will eventually glue together into the final executable.The .hi files are interface files which contain any information which GHC might need to know about the contents of the module while compiling other modules which depend on it. It contains things like the types of exported definitions you can see whats in a given .hi file using ghc showiface MyModule.hiTogether they contain enough information for GHC to not have to rebuild that module so long as it hasnt been modified saving time on future builds of your program.,haskellquestions,ciiv3p0,2,t5_2trze
2672551,0,t1_cn3wd9b,You will run into more problems when using this approach in haskell.  I dont want to say that you cannot do your approach but you are throwing away all the nice tools haskell gives you. static typing  By identifying an entity by its bitmask you basically implement dynamic typing.  type classes  To implement similar behavior on different data types you could easily use type classes. Extendibility  When using your approach you cannot easily extend your system.  You are tied to  properties of objects also it is no abstraction from the physical representation of the data at all.That said I think bitmasks are a wonderfull thing when writing in C and you can also implement them in Haskell but I dont know if you will be happy with the result.,haskellquestions,cn7fb9j,1,t5_2trze
4028173,0,t1_cret0my,I think so.  Maybe    type family Swaps a b c where        Swaps a b a  b        Swaps a b b  aFor the type family but youll also need some changes to the type class and there are a couple of ways to do that.  There also the stickiness that this allows a  b and theres no way to prevent that  GHC doesnt have a constraint for type inequality.You could have your type class still be single parameter    class HAble a where        h  a gt Swaps String Int aOr you could have some sort of multiparameter type class    class HAble a b c where        h  c gt Swaps a b cYou might also want functional dependencies there but Im not sure what theyd look like.,haskellquestions,crffwrs,1,t5_2trze
4197570,0,t3_38xsdb,gt Ive looked at using the state monad or something similar but with no luck.Can you be more specific? What exactly did you attempt and what didnt go as planned?,haskellquestions,crypvwd,1,t5_2trze
4286416,0,t3_39za2u,I think a streaming data library like conduit or pipes might help you want with this. Assuming you dont mind the dependency.,haskellquestions,cs8st61,1,t5_2trze
4609796,0,t1_ctbeyn7,Sorry I got what you were saying. Thanks!,haskellquestions,ctbnbmo,1,t5_2trze
5280825,0,t3_3nc55l,Did you try to turn on overlapping instances?    set XOverlappingInstances,haskellquestions,cvmoqhi,1,t5_2trze
5480514,0,t3_3pnzxh,At a glance your answers for   and  are wrong.  You must always use the second argument to fmap or contramap at least to check that it is not undefined and you must always use all data therein lest you violate the identity law.I think instead the goal of these exercises is to determine the position of a mentally.  It makes sense for an Int to be in covariant or contravariant position although it is not a type parameter so cannot be abstracted by Functor.It doesnt help that the excessive reliance on units makes it harder to type check your answers though.  Instead add a type parameter for each unit e.g.newtype E b c a  E b gt c gt a gt aE has  units so you would add bcde etc.Then your instance declarations look like instance ??? E b c and so on.,haskellquestions,cwc6qqh,2,t5_2trze
5912064,0,t1_cxulbgq,Well I thought my first version was crappy and had the wrong tone. Hope its helpful.,haskellquestions,cxulrcr,1,t5_2trze
6068618,0,t3_3ymthx,You cant do this with MonadThrow. The explicit purpose of that class is to provide the means of throwing any sort of exception not just a specific one. Handling only your type of exception is easy however    stuff lt catch e  MyException gt ... doStuff    For this to work MyException has to be an instance of the Exception class     LANGUAGE DeriveDataTypeable     data MyException  ... deriving Show Typeable    instance Exception MyExceptioncatch will automatically try to cast to your specific exception type and do nothing if it cant.If you really want the type to be Either MyException String you can write it that way directly    doStuff  Either MyException String    doStuff  do if  gt  then Left  MyException Mathematics is a lie                          else return Everythings fine,haskellquestions,cyf338l,1,t5_2trze
6116550,0,t3_3z8p5f,Just a simple solution. Its probably about ghci not understanding the two lets. Write like this    let factorial    factorial n  n  factorial nand it works perfectly and very fast. Keep function definitions in one line  ends the current declaration.,haskellquestions,cykvzpm,1,t5_2trze
6118260,0,t1_cyl2o96,Lets change the function a little bit in order to remove the use of Integer math which is slow so that all that is left is mostly the cost of recursion itself.    fa  Int gt Int    fa       fa n    fa n    fb  Int gt Int    fb n  go n  where        go  r  r        go n r  go n r    main  print  fb On this case compiled with O the tail recursive version fb is almost  times faster than the non tail recursive one fa.,haskellquestions,cyl2ziu,1,t5_2trze
6372587,0,t3_42wlxe,this formatting is brutally bad,haskellquestions,czdzr9n,3,t5_2trze
7385036,0,t3_4gh8la,Eithers are constructed with the type constructors Left and Right. In the case where you return numbers it should be Right  and in the other case it should be Left  map.... The type error is pretty informative in this case because the type of  is Int and the type of Right  is Either a Int.,haskellquestions,d2hmmnw,7,t5_2trze
7436858,0,t1_d2nim13,putStrLn is indeed not thread safe.,haskellquestions,d2niu19,4,t5_2trze
7570756,0,t3_4iyfng,Side note you can salvage interleaveStreams by making the second pattern lazy or irrefutable    interleaveStreams Cons x xs Cons y ys  Cons x Cons y interleaveStreams xs ysThis means that the second pattern is only matched when the value of either y or ys is required. Thus interleaveStreams can produce the first Cons without knowing anything about its second argument which breaks the infinite cycle mentioned by usidkap.The report has some more info on irrefutable patterns.,haskellquestions,d32ratq,2,t5_2trze
7898350,0,t1_d43tsdt,When I import both Control.Monad and Data.Foldable in GHC . I get an ambiguous occurrence error so I thought they were two different functions.In GHC . they are all the same now?,haskellquestions,d43ujs3,1,t5_2trze
8490091,0,t1_d62b22i,I think .. is too old for stack,haskellquestions,d62t51t,1,t5_2trze
8528861,0,t1_d67o08e,Thanks! I was wondering how to stop the proliferation of the impure functions.,haskellquestions,d67o6c9,1,t5_2trze
8588004,0,t1_d6ezl11,deleted,haskellquestions,d6f37xn,1,t5_2trze
8616981,0,t1_d6iougk,Beautiful thank you,haskellquestions,d6ipza4,1,t5_2trze
8829057,0,t1_d793dhm,Option c also works well with record wildcards,haskellquestions,d794o75,2,t5_2trze
8839981,0,t1_d7a3mjt,Huh. Thats a good question. Ive not worked with graph algorithms in Haskell though containers has Data.Graph and fgl is wellrecommended if poorly documented in the haddocks?. Working directly with a graph representation may be easier.,haskellquestions,d7afv52,1,t5_2trze
9889555,0,t1_dawl8kl,This is very interesting! I believe I understand your post although I will need time to fully understand the wisdom...,haskellquestions,dawmrc3,2,t5_2trze
11124935,0,t1_desxxxo,Right. I missed the bit about the transaction.I assume runner looks like this at the moment    runner  ReaderT Connection IO a gt ReaderT ConnectionPool IO a    runner withConn  ReaderT   pool gt      withResource pool   conn gt        withTransaction conn runReaderT withConn connThe basic way to do this without monadcontrol is to unwraprewrap the ExceptT transformer around withTransaction.    runner  ReaderT Connection ExceptT ErrorType IO a gt ReaderT ConnectionPool ExceptT ErrorType IO a    runner withConn  ReaderT   pool gt      withResource pool   conn gt        ExceptT withTransaction conn runExceptT runReaderT withConn connHowever this method isnt scalable if your transformer stack is growing.The standard transformers implement the MonadBaseControl type class to handle this unwrapping. The methods are somewhat lowlevel but here you need only    liftBaseOp  MonadBaseControl b m gt b StM m a gt b StM m c gt m a gt m cThe operation to lift here is withTransaction. Maybe the types look clearer if you instantiate b  IO the base monad m  ExceptT ErrorType IO the lifted monad a  c. Then StM ExceptT ErrorType IO a is defined as Either ErrorType a i.e. the result of an action unwrapped from ExceptT ErrorType IO a.    liftBaseOp  IO Either ErrorType a gt IO Either ErrorType a gt ExceptT ErrorType IO a gt ExceptT ErrorType IO a    withTransaction  Connection gt IO Either ErrorType a gt IO Either ErrorType aThen the following runner will adapt to any stack as long as ReaderT is at the top.    runner  MonadBaseControl IO m gt ReaderT Connection m a gt ReaderT ConnectionPool m a    runner withConn  ReaderT   pool gt      withResource pool   conn gt        liftBaseOp withTransaction conn runReaderT withConn connNote that withResource already uses that method.,haskellquestions,det031s,3,t5_2trze
11425997,0,t1_dfr2dh4,Awesome!The only suggestions I would make are to factor things out a bit more. You generally dont want to take an IO value as an input unless youre intentionally wanting a callback value for some reason. So extractBody can easily be    extractBody  Maybe Response ByteString gt IO Maybe ByteString    extractBody mresp          case mresp of            Nothing gt Nothing            Just response gt Just  response . Http.responseBodyWe can further simplify this by using the Functor instance for Maybe which takes the awfully common pattern     case foo of        Nothing gt Nothing        Just a gt Just someFunction aand allows us to write     fmap someFunction foogiving us    extractBody  Maybe Response ByteString gt Maybe ByteString    extractBody mresp          fmap response gt response . Http.responseBody mrespwhich can be further reduced to    extractBody  fmap view Http.responseBodysince .  view and eta reduction.,haskellquestions,dfr4im0,1,t5_2trze
