,controversiality,parent_id,body,subreddit,id,score,subreddit_id
429071,0,t3_1yzlru,You cant just define the square root as gt where does it end or will there always be a float after the gt and you only take the square root of that float?,dailyprogrammer_ideas,cfp8l7l,2,t5_2tny3
3342482,0,t3_2ydta5,For the record a couple of small mistakesTo determine whether or not it is a happy number you replace it by the square of its digits  gt sum of squares of its digitsLets see gt Lets seelets give gt lets giveWhich power from  to  produces gt needs extra comma before producesedit the more gt the most,dailyprogrammer_ideas,cp99nbf,2,t5_2tny3
5480428,0,t3_3q1hfq,I think this might be better as an intermediate challenge but other than that I like it,dailyprogrammer_ideas,cwc6cip,1,t5_2tny3
5978542,0,t3_3xc4b5,You can use this little tool I wrote to generate your own grid.    import random        freqs  a . b . c . d . e . f . g . h . i . j . k . l . m . n . o . p . q . r . s . t . u . v . w . x . y . z .        total  sumfreqs.values    def randomletter        r  random.uniform total        s          for letter freq in freqs.items            s  freq            if s gt r                return letter        def generategridx y        result          for  in rangey            result.append.joinrandomletter for  in rangex        return n.joinresult         usage printgenerategrid      generates a x grid,dailyprogrammer_ideas,cy3bg88,2,t5_2tny3
7018172,0,t3_4brdff,Scala      Edit Ive written a  tail recursive BFS version that is much faster than this one see below.Recursive bruteforce approach    this guard condition ifn gt  ampamp iter   gt n  return     makes it possible  to compute all the  solutions from  to  in  sec roughly.Without it this computation for numbers gt  would  be too slow.code    def toOperationSystemnIntListInt  var solution  VectorListInt  def recFindSoliterInt currValInt accListIntUnit    ifcurrVal  n      solution  acc      return        ifn gt  ampamp iter   gt n       return        else ifiter  n        return          else ifiter        recFindSol     Nil      recFindSol    Nil        else      val next  iter        recFindSolnext currVal  next   acc      recFindSolnext currVal  next   acc      recFindSolnext currVal  next   acc        recFindSol  Nil  solution.reducea b gt ifa.size lt b.size a else b.reversefori lt  to  res  toOperationSystemi.mkString   printlnsi decimal gt res operations output     decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations decimal gt  operations,dailyprogrammer_ideas,d1buwx5,3,t5_2tny3
7798132,0,t3_4m4ug1,deleted,dailyprogrammer_ideas,d3skjdk,1,t5_2tny3
8707843,0,t3_4yks3z,This is really basic and I think covered in most introductory programming textbooks at least in KampRC.,dailyprogrammer_ideas,d6u46h4,2,t5_2tny3
